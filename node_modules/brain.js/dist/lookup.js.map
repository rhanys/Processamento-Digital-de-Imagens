{"version":3,"sources":["../src/lookup.js"],"names":["lookup","hashes","hash","reduce","memo","Object","assign","toHash","data","table","tableIndex","dataIndex","length","p","input","hasOwnProperty","output","index","i","object","arrayLength","result","Float32Array","from","objects","push","toArray","array","offset","z"],"mappings":"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","file":"lookup.js","sourcesContent":["/* Functions for turning sparse hashes into arrays and vice versa */\nexport default class lookup {\n  /**\n   * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`\n   * @param {Object} hashes\n   * @returns {Object}\n   */\n  static toTable(hashes) {\n    const hash = hashes.reduce((memo, hash) => {\n      return Object.assign(memo, hash);\n    }, {});\n\n    return lookup.toHash(hash);\n  }\n\n  static toInputTable(data) {\n    const table = {};\n    let tableIndex = 0;\n    for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {\n      for (let p in data[dataIndex].input) {\n        if (!table.hasOwnProperty(p)) {\n          table[p] = tableIndex++;\n        }\n      }\n    }\n    return table;\n  }\n\n  static toOutputTable(data) {\n    const table = {};\n    let tableIndex = 0;\n    for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {\n      for (let p in data[dataIndex].output) {\n        if (!table.hasOwnProperty(p)) {\n          table[p] = tableIndex++;\n        }\n      }\n    }\n    return table;\n  }\n\n  /**\n   * performs `{a: 6, b: 7} -> {a: 0, b: 1}`\n   * @param {Object} hash\n   * @returns {Object}\n   */\n  static toHash(hash) {\n    let lookup = {};\n    let index = 0;\n    for (let i in hash) {\n      lookup[i] = index++;\n    }\n    return lookup;\n  }\n\n  /**\n   * performs `{a: 0, b: 1}, {a: 6} -> [6, 0]`\n   * @param {*} lookup\n   * @param {*} object\n   * @param {*} arrayLength\n   * @returns {Float32Array}\n   */\n  static toArray(lookup, object, arrayLength) {\n    const result = new Float32Array(arrayLength);\n    for (let p in lookup) {\n      result[lookup[p]] = object.hasOwnProperty(p) ? object[p] : 0;\n    }\n    return result;\n  }\n\n  static toArrayShort(lookup, object) {\n    const result = [];\n    for (let p in lookup) {\n      if (!object.hasOwnProperty(p)) break;\n      result[lookup[p]] = object[p];\n    }\n    return Float32Array.from(result);\n  }\n\n  static toArrays(lookup, objects, arrayLength) {\n    const result = [];\n    for (let i = 0; i < objects.length; i++) {\n      result.push(this.toArray(lookup, objects[i], arrayLength));\n    }\n    return result;\n  }\n\n  /**\n   * performs `{a: 0, b: 1}, [6, 7] -> {a: 6, b: 7}`\n   * @param {Object} lookup\n   * @param {Array} array\n   * @returns {Object}\n   */\n  static toObject(lookup, array) {\n    const object = {};\n    for (let p in lookup) {\n      object[p] = array[lookup[p]];\n    }\n    return object;\n  }\n\n  static toObjectPartial(lookup, array, offset) {\n    const object = {};\n    let i = 0;\n    for (let p in lookup) {\n      if (i++ < offset) continue;\n      object[p] = array[lookup[p] - offset];\n    }\n    return object;\n  }\n\n  /**\n   *\n   * @param {Array} array\n   * @returns {*}\n   */\n  static lookupFromArray(array) {\n    let lookup = {};\n    let z = 0;\n    let i = array.length;\n    while (i-- > 0) {\n      lookup[array[i]] = z++;\n    }\n    return lookup;\n  }\n}\n"]}